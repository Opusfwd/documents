"use strict";(self.webpackChunksmart_documents=self.webpackChunksmart_documents||[]).push([[3619],{3905:(n,e,t)=>{t.d(e,{Zo:()=>u,kt:()=>f});var i=t(7294);function s(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){s(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,i,s=function(n,e){if(null==n)return{};var t,i,s={},a=Object.keys(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||(s[t]=n[t]);return s}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(s[t]=n[t])}return s}var l=i.createContext({}),p=function(n){var e=i.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},u=function(n){var e=p(n.components);return i.createElement(l.Provider,{value:e},n.children)},m="mdxType",c={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},d=i.forwardRef((function(n,e){var t=n.components,s=n.mdxType,a=n.originalType,l=n.parentName,u=o(n,["components","mdxType","originalType","parentName"]),m=p(t),d=s,f=m["".concat(l,".").concat(d)]||m[d]||c[d]||a;return t?i.createElement(f,r(r({ref:e},u),{},{components:t})):i.createElement(f,r({ref:e},u))}));function f(n,e){var t=arguments,s=e&&e.mdxType;if("string"==typeof n||s){var a=t.length,r=new Array(a);r[0]=d;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=n,o[m]="string"==typeof n?n:s,r[1]=o;for(var p=2;p<a;p++)r[p]=t[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5693:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var i=t(7462),s=(t(7294),t(3905));const a={},r=void 0,o={unversionedId:"underWriteMe/healthQuestionIntegration",id:"underWriteMe/healthQuestionIntegration",title:"healthQuestionIntegration",description:"local healthQuestion integration for MY",source:"@site/documents/smart/underWriteMe/healthQuestionIntegration.md",sourceDirName:"underWriteMe",slug:"/underWriteMe/healthQuestionIntegration",permalink:"/smart/underWriteMe/healthQuestionIntegration",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"api",previous:{title:"healthQuestion",permalink:"/smart/underWriteMe/healthQuestion"}},l={},p=[{value:"local healthQuestion integration for MY",id:"local-healthquestion-integration-for-my",level:4}],u={toc:p},m="wrapper";function c(n){let{components:e,...a}=n;return(0,s.kt)(m,(0,i.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h4",{id:"local-healthquestion-integration-for-my"},"local healthQuestion integration for MY"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Data structure")),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Application",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"HQInfo",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"proposersHQ  // PC",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"isShow"),(0,s.kt)("li",{parentName:"ul"},"name "),(0,s.kt)("li",{parentName:"ul"},"path"),(0,s.kt)("li",{parentName:"ul"},"locale"),(0,s.kt)("li",{parentName:"ul"},"isSatisfied"),(0,s.kt)("li",{parentName:"ul"},"answers"),(0,s.kt)("li",{parentName:"ul"},"definition",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"name"),(0,s.kt)("li",{parentName:"ul"},"text"),(0,s.kt)("li",{parentName:"ul"},"type"),(0,s.kt)("li",{parentName:"ul"},"options"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"second"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"isShow"),(0,s.kt)("li",{parentName:"ul"},"sections",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"answer"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"isShow"),(0,s.kt)("li",{parentName:"ul"},"..."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"childSections"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"isShow"),(0,s.kt)("li",{parentName:"ul"},"..."))))))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ruleAnswer"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"isCheckRuleAnswer"),(0,s.kt)("li",{parentName:"ul"},"isShow"),(0,s.kt)("li",{parentName:"ul"},"..."))))),(0,s.kt)("li",{parentName:"ul"},"questionPartHQ // PC (following section)"),(0,s.kt)("li",{parentName:"ul"},"childHQ // CO"),(0,s.kt)("li",{parentName:"ul"},"questionPartForOwnerHQ // CO"))))))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"HealthQuestion UI")),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("img",{src:t(6491).Z,width:"1026",height:"1068"}))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("img",{src:t(3954).Z,width:"762",height:"644"}))))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Integration coding")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"import * as _ from 'lodash';\nimport {\n  experience,\n  condition,\n  backPain,\n  knee,\n} from '@/screens/application/tablet/tabs/yourDetail/healthquestion/DropDownInfo';\n\nconst commonOptions = ['Yes', 'No'];\n\nconst optionMap = {\n  OPTION1: experience,\n  OPTION2: condition,\n  OPTION3: backPain,\n  OPTION4: knee,\n};\n\nconst getQuestionTitle = ({ questionType, isOwner }) => {\n  const type = /FULL/.test(questionType) ? 'FUW' : 'SIO';\n  const relationship = isOwner ? 'CO' : 'PC';\n  return `Health Question_${type}_${relationship}`;\n};\n\nconst getHealthQuestion = ({ isPayer, isOwner, isInsured, HQInfo, applicationData }) => {\n  if ((!isOwner && isPayer) || !HQInfo) {\n    return [];\n  }\n\n  let healthQuestion, questionPart;\n\n  // PC || CO === PC\n  if (isInsured || applicationData?.insureds?.[0]?.relationship === 'SELF') {\n    // PC\n    healthQuestion = HQInfo?.proposersHQ;\n    questionPart = HQInfo?.questionPartHQ;\n  } else {\n    // CO\n    healthQuestion = HQInfo?.childHQ;\n    questionPart = HQInfo?.questionPartForOwnerHQ;\n  }\n\n  const name = getQuestionTitle({\n    questionType: HQInfo?.questionType,\n    isOwner,\n  });\n\n  if (!healthQuestion) {\n    return [];\n  }\n\n  const { questions, enquiryLines } = healthQuestion?.reduce(\n    (data, item, index) => {\n      if (item.isShow) {\n        const { questions, enquiryLines } = data;\n        const itemSection = getQuestion({ item, name });\n        const partSection = getQuestionPart({ index, item, name, questionPart });\n        const [ques, enquirys] = flattenQuestion(\n          _.compact([...partSection, itemSection]),\n          name,\n          questions,\n          enquiryLines,\n        );\n        return {\n          questions: ques,\n          enquiryLines: enquirys,\n        };\n      }\n      return data;\n    },\n    {\n      questions: [],\n      enquiryLines: [],\n    },\n  );\n\n  return !questions?.length && !enquiryLines.length\n    ? []\n    : [\n        {\n          name: name,\n          isSatisfied: true,\n          hasQuestions: true,\n          enquiryLines: [\n            {\n              name: name,\n              path: name,\n              section: name,\n              isSatisfied: true,\n              hasQuestions: true,\n              isRoot: true,\n              triggers: [],\n              triggerQuestions: {},\n              questions,\n            },\n            ...enquiryLines,\n          ],\n        },\n      ];\n};\n\nconst getQuestion = ({ item, name }) => {\n  const itemSection = {\n    ..._.pick(item, ['name', 'path', 'locale', 'isSatisfied', 'answers', 'definition']),\n    hasAnswer: !!item.answers,\n    triggers: [name],\n  };\n  if (item.isCheckRuleAnswer && item.ruleAnswer?.length) {\n    itemSection.questions = item.ruleAnswer?.reduce((data, el) => {\n      if (el.isShow) {\n        const name = el.text;\n        const answers = _.compact([el.answer, el.answer2]);\n        const newAnswers = optionMap[el.type]\n          ? answers?.map((ee) => optionMap[el.type].find((dl) => dl.name === ee)?.labelKey)\n          : answers;\n        const type = getType(el.type);\n        const options = getOptions(el?.type, el.options, newAnswers);\n        return [\n          ...data,\n          {\n            name: name,\n            path: name,\n            section: name,\n            triggers: [itemSection.name],\n            hasAnswer: true,\n            triggerQuestions: {},\n            isSatisfied: !!el?.isSatisfied,\n            answers: newAnswers,\n            definition: {\n              name: el.name,\n              text: el.text,\n              type: type,\n              isMultiValued: answers?.length > 1 ? true : false,\n              options: options,\n            },\n          },\n        ];\n      }\n      return data;\n    }, []);\n  }\n  if (item.second?.isShow && item.second?.sections?.length) {\n    itemSection.questions = item.second?.sections?.reduce((data, el) => {\n      if (el.isShow) {\n        let questions = [];\n        const name = el.title || el.placeholder;\n        if (el?.answer?.length && el?.answer?.[0]?.text) {\n          questions = el?.answer?.reduce((ans, dd) => {\n            const answer = getAnswer(dd.type, dd.answer);\n            const options = getOptions(dd?.type, dd.options, [answer]);\n            if (dd.isShow) {\n              return [\n                ...ans,\n                {\n                  name: dd.text,\n                  path: dd.text,\n                  section: dd.text,\n                  triggers: [name],\n                  hasAnswer: !!answer,\n                  triggerQuestions: {},\n                  answers: [answer],\n                  definition: {\n                    name: dd.text,\n                    text: dd.text,\n                    type: getType(dd.type),\n                    options,\n                  },\n                },\n              ];\n            }\n            return ans;\n          }, []);\n        }\n        if (el?.childSections?.length && el?.childSections?.[0]?.title) {\n          questions = el?.childSections?.reduce((childs, dd) => {\n            if (dd.isShow) {\n              return [\n                ...childs,\n                {\n                  name: dd.title,\n                  path: dd.title,\n                  section: dd.title,\n                  triggers: [name],\n                  hasAnswer: !!dd.answer,\n                  triggerQuestions: {},\n                  answers: [dd.answer],\n                  definition: {\n                    name: dd.title,\n                    text: dd.title,\n                    type: getType(dd.childType),\n                    options: dd.options,\n                  },\n                },\n              ];\n            }\n            return childs;\n          }, []);\n        }\n        return [\n          ...data,\n          {\n            name: name,\n            path: name,\n            section: name,\n            triggers: [itemSection.name],\n            hasAnswer: true,\n            triggerQuestions: {},\n            answers: el.type === 'CHECKBOX' ? [commonOptions[el.isCheck ? 0 : 1]] : [el.answer],\n            definition: {\n              name: name,\n              text: name,\n              type: getType(el.type),\n              options: el.type === 'CHECKBOX' ? commonOptions : el.options,\n            },\n            questions,\n          },\n        ];\n      }\n      return data;\n    }, []);\n  }\n\n  return itemSection;\n};\n\nconst getQuestionPart = ({ index, name, item, questionPart }) => {\n  const partSection = [];\n  if (index === 3 && questionPart) {\n    const partName = 'Have you ever been diagnosed with or had symptoms of any of the following';\n    const hasAnswer = !!questionPart?.find((el) => el.answer && el.answer === 'Yes');\n    const partSectionTemp = {\n      name: partName,\n      path: partName,\n      section: partName,\n      triggers: [name],\n      hasAnswer: true,\n      triggerQuestions: {},\n      answers: [commonOptions[hasAnswer ? 0 : 1]],\n      definition: {\n        name: partName,\n        text: partName,\n        options: commonOptions,\n      },\n      questions: questionPart.map((sec) => ({\n        name: sec.name,\n        path: sec.name,\n        locale: item.locale,\n        hasAnswer: !!sec?.answer,\n        isSatisfied: !!sec?.isSatisfied,\n        answers: [sec?.answer],\n        triggers: [partName],\n        definition: {\n          name: sec?.name,\n          text: sec?.text,\n          isMultiValued: false,\n          options: commonOptions,\n        },\n        questions: sec?.second?.reduce((ques, second) => {\n          if (second.isShow) {\n            const answers = commonOptions[second?.isCheck ? 0 : 1];\n            return [\n              ...ques,\n              {\n                name: second.name,\n                path: second.name,\n                locale: item.locale,\n                hasAnswer: !!answers,\n                isSatisfied: !!second?.isSatisfied,\n                answers: [answers],\n                triggers: [sec?.name],\n                definition: {\n                  name: second.name,\n                  text: second.name,\n                  isMultiValued: false,\n                  options: commonOptions,\n                },\n                questions: second?.answer?.reduce((ans, el) => {\n                  if (el.isShow) {\n                    const answers = _.compact([el.answer, el.answer2]);\n                    const newAnswers = optionMap[el.type]\n                      ? answers?.map((ee) => optionMap[el.type].find((dl) => dl.name === ee)?.labelKey)\n                      : answers;\n                    const type = getType(el.type);\n                    const options = getOptions(el?.type, el.options, newAnswers);\n                    return [\n                      ...ans,\n                      {\n                        name: el.name,\n                        path: el.name,\n                        locale: item.locale,\n                        hasAnswer: !!newAnswers,\n                        isSatisfied: !!el?.isSatisfied,\n                        answers: newAnswers,\n                        triggers: [second.name],\n                        definition: {\n                          name: el.name,\n                          text: el.text,\n                          type: type,\n                          isMultiValued: answers?.length > 1 ? true : false,\n                          options: options,\n                        },\n                      },\n                    ];\n                  }\n                  return ans;\n                }, []),\n              },\n            ];\n          }\n          return ques;\n        }, []),\n      })),\n    };\n    partSection.push(partSectionTemp);\n  }\n  return partSection;\n};\n\nconst getType = (type) => {\n  if (optionMap[type] || type === 'CHECKBOX') {\n    return 'OPTION_GROUP';\n  }\n  if (type === 'STRINGGROUP') {\n    return 'STRING_GROUP';\n  }\n  if (type === 'STRING') {\n    return 'NUMBER';\n  }\n  return type;\n};\n\nconst getAnswer = (type, answer) => {\n  const optionList = optionMap[type];\n  const newAnswer = optionList ? optionList.find((el) => el.name === answer)?.labelKey : answer;\n  return newAnswer;\n};\n\nconst getOptions = (type, options, answers) => {\n  const newOptions = optionMap[type]?.map?.(({ labelKey }) => labelKey) || options;\n  if (type === 'OPTION_GROUP') {\n    return commonOptions;\n  }\n  if (type === 'STRINGGROUP' && answers) {\n    return answers;\n  }\n  return newOptions;\n};\n\nconst flattenQuestion = (questionsArrs, rootName, questions, enquiryLines) => {\n  const flatSection = (item, rootItem) => {\n    const rootData = rootItem || item;\n    const parentName = item.triggers?.[0];\n    const isRoot = item.triggers?.[0] === rootName;\n    const data = _.omit(item, 'questions');\n    if (data.definition?.options?.includes('No')) {\n      data.definition.options = data.definition?.options.sort((a, b) => b.localeCompare(a));\n      if (!data.definition?.type) {\n        data.definition.type = 'OPTION_GROUP';\n      }\n    }\n\n    if (isRoot) {\n      questions.push(data);\n    } else {\n      const parentIndex = enquiryLines?.findIndex((el) => el.name === parentName);\n      if (parentIndex > -1) {\n        enquiryLines[parentIndex].questions.push(data);\n      } else {\n        enquiryLines.push({\n          name: parentName,\n          path: parentName,\n          section: parentName,\n          triggers: [parentName],\n          isSatisfied: true,\n          hasQuestions: true,\n          isRoot: false,\n          triggerQuestions: {},\n          referAnswer: rootData?.answers?.[0],\n          questions: [data],\n        });\n      }\n    }\n    if (item.questions) {\n      item.questions?.map((el) => flatSection(el, item));\n    }\n  };\n  questionsArrs?.map((item) => flatSection(item));\n  return [questions, enquiryLines];\n};\n\nexport default getHealthQuestion;\n\n")))}c.isMDXComponent=!0},6491:(n,e,t)=>{t.d(e,{Z:()=>i});const i=t.p+"assets/images/healthQuestion-6549e70eb4d04eedf7c9e954872b8bce.png"},3954:(n,e,t)=>{t.d(e,{Z:()=>i});const i=t.p+"assets/images/healthQuestionPopUp-0f19790f2a73ebf50f26631ce8ed3873.png"}}]);